# PLANNING.MD - Insta-Voice-Assistant (LiveKit MVP)

## Project Goal (MVP)

To create a real-time AI voice assistant for a SaaS product, enabling users to ask account-related questions and get support via voice. The project focuses on learning and implementing a complete voice AI solution including real-time interaction (LiveKit), RAG for knowledge retrieval, basic user authentication, and a custom frontend.

## Core Architecture

### 1. Frontend

- **Framework**: User's choice (e.g., React, Vue, Next.js, or plain HTML/JS).
- **LiveKit Integration**: Use LiveKit Client SDK (e.g., `livekit-client` for JavaScript) to connect to the LiveKit room, handle audio streams, and manage session state.
- **Authentication**: Integrate with Firebase Authentication to handle user login (e.g., Google Sign-In or Email/Password).

### 2. Realtime Communication & Agent Orchestration

- **Framework**: LiveKit Agents SDK (Python)
  - **Responsibilities**: Handles real-time audio streaming (WebRTC) from the frontend, agent lifecycle management, and orchestration of AI services.
  - **Key Classes**: `AgentSession` for managing interactions, `Agent` for defining core logic and tools.
- **Signaling & Media Server**: LiveKit Server (LiveKit Cloud recommended for ease of setup).

### 3. AI Services (OpenAI-driven)

- **Primary Language & Speech Model**: `livekit.plugins.openai.realtime.RealtimeModel`
  - **Functionality**: Provides an integrated speech-to-speech experience (STT, LLM, TTS) for low-latency conversational turns.
- **Dedicated Text-to-Speech (for proactive agent speech)**: `livekit.plugins.openai.TTS`
- **Voice Activity Detection (VAD)**: `livekit.plugins.silero.VAD`
- **Function Calling / Tools**: Defined in `backend/api.py` for interacting with Supabase (user data, KB) and managing session state.

### 4. Backend Services & Database (Supabase + Firebase)

- **User Authentication**: Firebase Authentication
  - **Responsibilities**: Manages user sign-up, sign-in, and session tokens.
  - The LiveKit agent will receive the authenticated user's ID (e.g., via the LiveKit token generated by a backend function).
- **User Data & Knowledge Base**: Supabase (PostgreSQL)
  - **User Data**: Stores user profiles linked by Firebase UID (e.g., `user_id`, `name`, `email`, `subscription_tier`, `last_interaction_summary`).
  - **Company Knowledge Base (KB) for RAG**: Simple table in Supabase storing text chunks and their embeddings (using `pgvector`).
  - **Interaction**: `backend/db_driver.py` using `supabase-py`.

### 5. Environment & Session Management

- **Local Environment**: Python Virtual Environment (`backend/ai/`).
- **Secrets Management**: `python-dotenv` (`backend/.env`).
- **Session Memory**:
  - **In-Call**: `RunContext.userdata`.
  - **Across Calls (Simplified)**: Load/save concise "last_interaction_summary" to the user's Supabase profile.

## Key Design Principles for MVP

- **End-to-End User Experience**: Focus on a functional flow from login on a custom frontend to voice interaction and useful responses.
- **Simplified RAG**: Use `pgvector` with Supabase for manageable KB.
- **Lean Authentication**: Firebase for basic user login.
- **Focus on Core Voice AI & Customer Support Use Case**.

## File Structure

```
Insta-Voice-Assistant-/
├── frontend/            # Custom frontend application
│   └── ... (e.g., src/, public/)
├── backend/
│   ├── ai/              # Python virtual environment
│   ├── .env             # API keys and secrets
│   ├── agent.py         # LiveKit agent setup
│   ├── api.py           # Tool definitions
│   ├── db_driver.py     # Supabase interaction logic
│   ├── prompts.py       # LLM instructions
│   ├── requirements.txt # Python dependencies
│   └── (utils.py)       # Optional: for KB embedding, token generation
├── PLANNING.md        # This file
├── TASK.MD            # Task tracking
└── README.md          # Project overview
```

## Out of Scope for this MVP (can be Phase 2)

- Advanced RAG (complex chunking, multiple data sources beyond simple text).
- Extensive call logging and detailed analytics (basic agent logs are fine).
- Admin dashboard.
- Strict latency NFRs (aim for good performance).
- Scaling to many concurrent users (focus on single-user functionality for MVP).
- Sophisticated data encryption beyond service defaults.
